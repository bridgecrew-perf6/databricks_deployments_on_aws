AWSTemplateFormatVersion: 2010-09-09
Description: Custom resources wrapping the Databricks Account API

#-------------------------------------------------------------------------
Parameters:

  ResourceOwner:
    Description: The value of the Owner tag in the created resources on AWS
    Type: String

  ResourcePrefix:
    Description: The prefix for the created resource names
    Type: String
    Default: DatabricksAccountAPI

  ExistingRoleArnForLambda:
    Description: The ARN of an existing role for the custom resource Lambda functions
    Type: String
    Default: ''

#-------------------------------------------------------------------------
Conditions:

  CreateRoleForLambda:
    !Equals [!Ref ExistingRoleArnForLambda, ""]

#-------------------------------------------------------------------------
Mappings:

  DatabricksAddresses:
    us-east-1:
      "workspace": "com.amazonaws.vpce.us-east-1.vpce-svc-09143d1e626de2f04"
      "backend": "com.amazonaws.vpce.us-east-1.vpce-svc-00018a8c3ff62ffdf"
      "webapp": "nvirginia.cloud.databricks.com"
      "sccrelay": "tunnel.us-east-1.cloud.databricks.com"
      "rds": "mdb7sywh50xhpr.chkweekm4xjq.us-east-1.rds.amazonaws.com"
      "controlplane": "3.237.73.224/28"
    us-east-2:
      "workspace": "com.amazonaws.vpce.us-east-2.vpce-svc-041dc2b4d7796b8d3"
      "backend": "com.amazonaws.vpce.us-east-2.vpce-svc-090a8fab0d73e39a6"
      "webapp": "ohio.cloud.databricks.com"
      "sccrelay": "tunnel.us-east-2.cloud.databricks.com"
      "rds": "md7wf1g369xf22.cluz8hwxjhb6.us-east-2.rds.amazonaws.com"
      "controlplane": "3.128.237.208/28"
    us-west-1:
      "workspace": "UNSUPPORTED"
      "backend": "UNSUPPORTED"
      "webapp": "oregon.cloud.databricks.com"
      "sccrelay": "tunnel.cloud.databricks.com"
      "rds": "mdzsbtnvk0rnce.c13weuwubexq.us-west-1.rds.amazonaws.com"
      "controlplane": "44.234.192.32/28"
    us-west-2:
      "workspace": "com.amazonaws.vpce.us-west-2.vpce-svc-0129f463fcfbc46c5"
      "backend": "com.amazonaws.vpce.us-west-2.vpce-svc-0158114c0c730c3bb"
      "webapp": "oregon.cloud.databricks.com"
      "sccrelay": "tunnel.cloud.databricks.com"
      "rds": "mdpartyyphlhsp.caj77bnxuhme.us-west-2.rds.amazonaws.com"
      "controlplane": "44.234.192.32/28"
    eu-west-1:
      "workspace": "com.amazonaws.vpce.eu-west-1.vpce-svc-0da6ebf1461278016"
      "backend": "com.amazonaws.vpce.eu-west-1.vpce-svc-09b4eb2bc775f4e8c"
      "webapp": "ireland.cloud.databricks.com"
      "sccrelay": "tunnel.eu-west-1.cloud.databricks.com"
      "rds": "md15cf9e1wmjgny.cxg30ia2wqgj.eu-west-1.rds.amazonaws.com"
      "controlplane": "3.250.244.112/28"
    eu-west-2:
      "workspace": "com.amazonaws.vpce.eu-west-2.vpce-svc-01148c7cdc1d1326c"
      "backend": "com.amazonaws.vpce.eu-west-2.vpce-svc-05279412bf5353a45"
      "webapp": "london.cloud.databricks.com"
      "sccrelay": "tunnel.eu-west-2.cloud.databricks.com"
      "rds": "mdio2468d9025m.c6fvhwk6cqca.eu-west-2.rds.amazonaws.com"
      "controlplane": "18.134.65.240/28"
    eu-central-1:
      "workspace": "com.amazonaws.vpce.eu-central-1.vpce-svc-081f78503812597f7"
      "backend": "com.amazonaws.vpce.eu-central-1.vpce-svc-08e5dfca9572c85c4"
      "webapp": "frankfurt.cloud.databricks.com"
      "sccrelay": "tunnel.eu-central-1.cloud.databricks.com"
      "rds": "mdv2llxgl8lou0.ceptxxgorjrc.eu-central-1.rds.amazonaws.com"
      "controlplane": "18.159.44.32/28"
    ap-southeast-1:
      "workspace": "com.amazonaws.vpce.ap-southeast-1.vpce-svc-02535b257fc253ff4"
      "backend": "com.amazonaws.vpce.ap-southeast-1.vpce-svc-0557367c6fc1a0c5c"
      "webapp": "singapore.cloud.databricks.com"
      "sccrelay": "tunnel.ap-southeast-1.cloud.databricks.com"
      "rds": "md1n4trqmokgnhr.csnrqwqko4ho.ap-southeast-1.rds.amazonaws.com"
      "controlplane": "13.214.1.96/28"
    ap-southeast-2:
      "workspace": "com.amazonaws.vpce.ap-southeast-2.vpce-svc-0b87155ddd6954974"
      "backend": "com.amazonaws.vpce.ap-southeast-2.vpce-svc-0b4a72e8f825495f6"
      "webapp": "sydney.cloud.databricks.com"
      "sccrelay": "tunnel.ap-southeast-2.cloud.databricks.com"
      "rds": "mdnrak3rme5y1c.c5f38tyb1fdu.ap-southeast-2.rds.amazonaws.com"
      "controlplane": "3.26.4.0/28"
    ap-northeast-1:
      "workspace": "com.amazonaws.vpce.ap-northeast-1.vpce-svc-02691fd610d24fd64"
      "backend": "com.amazonaws.vpce.ap-northeast-1.vpce-svc-02aa633bda3edbec0"
      "webapp": "tokyo.cloud.databricks.com"
      "sccrelay": "tunnel.ap-northeast-1.cloud.databricks.com"
      "rds": "mddx5a4bpbpm05.cfrfsun7mryq.ap-northeast-1.rds.amazonaws.com"
      "controlplane": "35.72.28.0/28"
    ap-south-1:
      "workspace": "com.amazonaws.vpce.ap-south-1.vpce-svc-0dbfe5d9ee18d6411"
      "backend": "com.amazonaws.vpce.ap-south-1.vpce-svc-03fd4d9b61414f3de"
      "webapp": "mumbai.cloud.databricks.com"
      "sccrelay": "tunnel.ap-south-1.cloud.databricks.com"
      "rds": "mdjanpojt83v6j.c5jml0fhgver.ap-south-1.rds.amazonaws.com"
      "controlplane": "65.0.37.64/28"
    ca-central-1:
      "workspace": "com.amazonaws.vpce.ca-central-1.vpce-svc-0205f197ec0e28d65"
      "backend": "com.amazonaws.vpce.ca-central-1.vpce-svc-0c4e25bdbcbfbb684"
      "webapp": "canada.cloud.databricks.com"
      "sccrelay": "tunnel.ca-central-1.cloud.databricks.com"
      "rds": "md1w81rjeh9i4n5.co1tih5pqdrl.ca-central-1.rds.amazonaws.com"
      "controlplane": "3.96.84.208/28"

#-------------------------------------------------------------------------
Resources:

  # Role for functions
  BaseLambdaRole:
    Condition: CreateRoleForLambda
    Type: AWS::IAM::Role
    Properties: 
      RoleName: !Sub ${ResourcePrefix}-CustomResourceFunctionRole
      Description: Basic execution role for the CloudFormation custom resource Lambda functions using the Databricks Account API
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
              - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-CustomResourceFunctionRolePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowWritingToLogs
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - arn:aws:logs:*:*:log-group:/aws/lambda/*:log-stream:*
              - Sid: AllowEndpointCreation
                Effect: Allow
                Action: ec2:CreateVpcEndpoint
                Resource:
                  - arn:aws:ec2:*:*:vpc/*
                  - arn:aws:ec2:*:*:security-group/*
                  - arn:aws:ec2:*:*:subnet/*
              - Sid: RestrictEndpointCreation
                Effect: Allow
                Action:
                  - ec2:CreateVpcEndpoint
                  - ec2:CreateTags
                  - ec2:DeleteVpcEndpoints
                Resource: 'arn:aws:ec2:*:*:vpc-endpoint/*'
                Condition:
                  "StringEquals":
                    "ec2:VpceServiceName":
                      - com.amazonaws.vpce.us-east-1.vpce-svc-09143d1e626de2f04
                      - com.amazonaws.vpce.us-east-1.vpce-svc-00018a8c3ff62ffdf
                      - com.amazonaws.vpce.us-east-2.vpce-svc-041dc2b4d7796b8d3
                      - com.amazonaws.vpce.us-east-2.vpce-svc-090a8fab0d73e39a6
                      - com.amazonaws.vpce.us-west-2.vpce-svc-0129f463fcfbc46c5
                      - com.amazonaws.vpce.us-west-2.vpce-svc-0158114c0c730c3bb
                      - com.amazonaws.vpce.eu-west-1.vpce-svc-0da6ebf1461278016
                      - com.amazonaws.vpce.eu-west-1.vpce-svc-09b4eb2bc775f4e8c
                      - com.amazonaws.vpce.eu-west-2.vpce-svc-01148c7cdc1d1326c
                      - com.amazonaws.vpce.eu-west-2.vpce-svc-05279412bf5353a45
                      - com.amazonaws.vpce.eu-central-1.vpce-svc-081f78503812597f7
                      - com.amazonaws.vpce.eu-central-1.vpce-svc-08e5dfca9572c85c4
                      - com.amazonaws.vpce.ap-southeast-1.vpce-svc-02535b257fc253ff4
                      - com.amazonaws.vpce.ap-southeast-1.vpce-svc-0557367c6fc1a0c5c
                      - com.amazonaws.vpce.ap-southeast-2.vpce-svc-0b87155ddd6954974
                      - com.amazonaws.vpce.ap-southeast-2.vpce-svc-0b4a72e8f825495f6
                      - com.amazonaws.vpce.ap-northeast-1.vpce-svc-02691fd610d24fd64
                      - com.amazonaws.vpce.ap-northeast-1.vpce-svc-02aa633bda3edbec0
                      - com.amazonaws.vpce.ap-south-1.vpce-svc-0dbfe5d9ee18d6411
                      - com.amazonaws.vpce.ap-south-1.vpce-svc-03fd4d9b61414f3de
                      - com.amazonaws.vpce.ca-central-1.vpce-svc-0205f197ec0e28d65
                      - com.amazonaws.vpce.ca-central-1.vpce-svc-0c4e25bdbcbfbb684
              - Sid: AllowEndpointModification
                Effect: Allow
                Action: ec2:ModifyVpcEndpoint
                Resource:
                  - arn:aws:ec2:*:*:vpc-endpoint/*
              - Sid: AllowDescribes
                Effect: Allow
                Action:
                  - ec2:DescribeVpcEndpoints
                  - ec2:DescribeVpcs
                Resource: '*'
              - Sid: AllowVPCAssociationWithHostedZone
                Effect: Allow
                Action:
                  - route53:AssociateVPCWithHostedZone
                  - route53:DisassociateVPCFromHostedZone
                Resource:
                  - arn:aws:route53:::hostedzone/*
                  - arn:aws:ec2:*:*:vpc/*
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner


  # Databricks Addresses
  DatabricksAddressesFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-DatabricksAddresses
      Description: The custom resource function to retrieve the public addresses of Databricks in the region
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile:  !Sub 
          - |
            import cfnresponse, socket
            def lambda_handler(event, context):
              attributes = {} if event['RequestType'] == 'Delete' else {"Webapp" : "${webapp}", "SCCRelay" : "${sccrelay}", "Metastore" : "${rds}", "MetastoreIP" : socket.gethostbyname("${rds}"), "ControlPlane" : "${controlplane}"}
              cfnresponse.send(event, context, cfnresponse.SUCCESS, attributes)
          - webapp: !FindInMap [DatabricksAddresses, !Ref AWS::Region, webapp]
            sccrelay: !FindInMap [DatabricksAddresses, !Ref AWS::Region, sccrelay]
            rds: !FindInMap [DatabricksAddresses, !Ref AWS::Region, rds]
            controlplane: !FindInMap [DatabricksAddresses, !Ref AWS::Region, controlplane]
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  DatabricksAddressesLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${DatabricksAddressesFn}
      RetentionInDays: 365


  # Credentials configuration
  CredentialsConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-CredentialsConfiguration
      Description: The custom resource function to create a credentials configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            if event['RequestType'] == 'Update': # No updates are supported
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              return
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              for propertName in ('CrossAccountRoleArn', 'CredentialsName'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "credentials_name": event['ResourceProperties']['CredentialsName'],
                "aws_credentials": { "sts_role": { "role_arn": event['ResourceProperties']['CrossAccountRoleArn'] } }
              }
              response = http.request('POST', accountsAPIBaseURL + '/credentials', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
              else:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['credentials_id'])
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/credentials/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  CredentialsConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${CredentialsConfigurationFn}
      RetentionInDays: 365


  # Storage configuration
  StorageConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-StorageConfiguration
      Description: The custom resource function to create a storage configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            if event['RequestType'] == 'Update': # No updates are supported
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              return
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              for propertName in ('RootBucket', 'StorageName'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "storage_configuration_name": event['ResourceProperties']['StorageName'],
                "root_bucket_info": { "bucket_name": event['ResourceProperties']['RootBucket'] }
              }
              response = http.request('POST', accountsAPIBaseURL + '/storage-configurations', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
              else:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['storage_configuration_id'])
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/storage-configurations/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  StorageConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${StorageConfigurationFn}
      RetentionInDays: 365


  ### The VPC Endpoint for the Databricks AWS PrivateLink
  VpcEnpointFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-VpcEnpoint
      Description: The custom resource function to create a Databricks VPC endpoint
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 600
      Code:
        ZipFile: !Sub 
          - |
            import cfnresponse, urllib3, json, boto3, time
            region = "${AWS::Region}"
            ec2Client = boto3.session.Session(region_name=region).client('ec2')
            def waitForEndpointDeletion(vpcEndpointId):
              while True:
                try:
                  status = ec2Client.describe_vpc_endpoints(Filters=[{'Name':'vpc-endpoint-id', 'Values': [vpcEndpointId]}])['VpcEndpoints'][0]['State']
                  time.sleep(5)
                except Exception as e: break
            def waitForEndpoint(vpcEndpointId):
              while True: # Wait for the endpoint to become available
                try:
                  status = ec2Client.describe_vpc_endpoints(Filters=[{'Name':'vpc-endpoint-id', 'Values': [vpcEndpointId]}])['VpcEndpoints'][0]['State']
                  if status == 'available': break
                except Exception as e: print(str(e))
                time.sleep(5)
            def checkForMissingProperty(properties, propertyName):
              if propertyName not in properties:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
                return True
              return False
            def lambda_handler(event, context):
              if event['RequestType'] == 'Update': # No updates are supported
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                return
              for propertName in ('DatabricksAccountId', 'Username', 'Password', 'Service'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              serviceName = "${ServiceNameWorkspace}" if event['ResourceProperties']['Service'] == 'Workspace' else "${ServiceNameBackend}"
              accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
              myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
              http = urllib3.PoolManager()
              if event['RequestType'] == 'Create':
                for propertName in ('EndpointName', 'VpcId', 'Subnets', 'SecurityGroups'):
                  if checkForMissingProperty(event['ResourceProperties'], propertName): return
                vpcEndpointId = None
                try: # Create the endpoint in the VPC
                  vpcEndpointId = ec2Client.create_vpc_endpoint(VpcEndpointType='Interface', VpcId=event['ResourceProperties']['VpcId'],
                    ServiceName=serviceName, SubnetIds=event['ResourceProperties']['Subnets'], SecurityGroupIds=event['ResourceProperties']['SecurityGroups'],
                    TagSpecifications=[{"ResourceType": "vpc-endpoint","Tags": [{"Key": "Owner", "Value": "${ResourceOwner}"}]}])['VpcEndpoint']['VpcEndpointId']
                except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = str(e))
                  return
                postData = {"vpc_endpoint_name": event['ResourceProperties']['EndpointName'], "aws_vpc_endpoint_id": vpcEndpointId, "region": region}
                response = http.request('POST', accountsAPIBaseURL + '/vpc-endpoints', headers=myHeaders, body = json.dumps(postData))
                if response.status != 201:
                  try:
                    ec2Client.delete_vpc_endpoints(VpcEndpointIds = [vpcEndpointId])
                    waitForEndpointDeletion(vpcEndpointId)
                  except Exception as e: print(str(e))
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(response.data.decode())['message']
                  except: errorMessage = response.reason
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                  return
                dbsVpcEndpointId = json.loads(response.data.decode())['vpc_endpoint_id']
                waitForEndpoint(vpcEndpointId)
                try:
                  ec2Client.modify_vpc_endpoint(VpcEndpointId=vpcEndpointId, PrivateDnsEnabled=True)
                except Exception as e:
                  print(e)
                  try: ec2Client.delete_vpc_endpoints(VpcEndpointIds = [vpcEndpointId])
                  except: pass
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = str(e))
                  return
                waitForEndpoint(vpcEndpointId)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, dbsVpcEndpointId)
              else: # 'Delete':
                response = http.request('GET', accountsAPIBaseURL + '/vpc-endpoints/' + event['PhysicalResourceId'], headers=myHeaders)
                if response.status != 200:
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(response.data.decode())['message']
                  except: errorMessage = response.reason
                  print(errorMessage)
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                  return
                endpointData = json.loads(response.data.decode())
                vpc_endpoint_id = endpointData['vpc_endpoint_id']
                aws_vpc_endpoint_id = endpointData['aws_vpc_endpoint_id']
                try:
                  ec2Client.delete_vpc_endpoints(VpcEndpointIds = [aws_vpc_endpoint_id])
                  response = http.request('DELETE', accountsAPIBaseURL + '/vpc-endpoints/' + vpc_endpoint_id, headers=myHeaders)
                  if response.status != 200:
                    errorMessage = 'Unknown Error'
                    try: errorMessage = json.loads(response.data.decode())['message']
                    except: errorMessage = response.reason
                    print(errorMessage)
                  waitForEndpointDeletion(aws_vpc_endpoint_id)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = str(e))
          - ServiceNameWorkspace: !FindInMap [DatabricksAddresses, !Ref AWS::Region, workspace]
            ServiceNameBackend: !FindInMap [DatabricksAddresses, !Ref AWS::Region, backend]
  VpcEnpointLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${VpcEnpointFn}
      RetentionInDays: 365


  ### The network configuration
  NetworkConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-NetworkConfiguration
      Description: The custom resource function to create a network configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              if 'NetworkName' not in event['ResourceProperties']:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No NetworkName property specified")
                return
              if 'VpcId' not in event['ResourceProperties']:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No VpcId property specified")
                return
              if ('Subnets' not in event['ResourceProperties']) or type(event['ResourceProperties']['Subnets']) != list:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No Subnets property specified")
                return
              if ('SecurityGroups' not in event['ResourceProperties']) or type(event['ResourceProperties']['SecurityGroups']) != list:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No SecurityGroups property specified")
                return
              postData = {
                "network_name": event['ResourceProperties']['NetworkName'],
                "vpc_id": event['ResourceProperties']['VpcId'],
                "subnet_ids": event['ResourceProperties']['Subnets'],
                "security_group_ids": event['ResourceProperties']['SecurityGroups']
              }
              if ('VpcEndpoints' in event['ResourceProperties']) and (type(event['ResourceProperties']) == dict) and \
                ('RestApiEndpointId' in event['ResourceProperties']['VpcEndpoints']) and ('DataplaneRelayEndpointId' in event['ResourceProperties']['VpcEndpoints']) and \
                (event['ResourceProperties']['VpcEndpoints']['RestApiEndpointId'] is not None) and (len(event['ResourceProperties']['VpcEndpoints']['RestApiEndpointId']) > 0) and \
                (event['ResourceProperties']['VpcEndpoints']['DataplaneRelayEndpointId'] is not None) and (len(event['ResourceProperties']['VpcEndpoints']['DataplaneRelayEndpointId']) > 0):
                postData["vpc_endpoints"] = { "rest_api": [ event['ResourceProperties']['VpcEndpoints']['RestApiEndpointId'] ], "dataplane_relay": [ event['ResourceProperties']['VpcEndpoints']['DataplaneRelayEndpointId'] ] }
              response = http.request('POST', accountsAPIBaseURL + '/networks', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['network_id'])
              return
            if event['RequestType'] == 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/networks/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  NetworkConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${NetworkConfigurationFn}
      RetentionInDays: 365


  ### The private access configuration
  PrivateAccessConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-PrivateAccessConfiguration
      Description: The custom resource function to create a private access configuration for a Databricks workspace
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: !Sub |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] in ('Create', 'Update'):
              for propertName in ('PrivateAccessSettingsName', 'PublicAccessEnabled', 'AllowedVpcEndpoints'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "private_access_settings_name": event['ResourceProperties']['PrivateAccessSettingsName'],
                "region": "${AWS::Region}",
                "public_access_enabled": event['ResourceProperties']['PublicAccessEnabled'],
                "private_access_level": "ENDPOINT",
                "allowed_vpc_endpoint_ids": event['ResourceProperties']['AllowedVpcEndpoints']
              }
              response = None
              if event['RequestType'] == 'Create':
                response = http.request('POST', accountsAPIBaseURL + '/private-access-settings', headers=myHeaders, body = json.dumps(postData))
              else:
                response = http.request('PUT', accountsAPIBaseURL + '/private-access-settings/' + event['PhysicalResourceId'], headers=myHeaders, body = json.dumps(postData))
              if response.status not in (200, 201):
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['private_access_settings_id'])
              return
            if event['RequestType'] == 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/private-access-settings/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  PrivateAccessConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${PrivateAccessConfigurationFn}
      RetentionInDays: 365


  ### The managed keys configuration
  ManagedKeysConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-ManagedKeysConfiguration
      Description: The custom resource function to create a customer managed keys configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              if 'KeyArn' not in event['ResourceProperties']:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No KeyArn property specified")
                return
              if ('UseCases' not in event['ResourceProperties']) or (type(event['ResourceProperties']['UseCases']) != list):
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No UseCases property specified")
                return
              postData = {
                "aws_key_info": { "key_arn": event['ResourceProperties']['KeyArn'] },
                "use_cases": event['ResourceProperties']['UseCases']
              }
              if 'KeyAlias' in event['ResourceProperties']:
                postData['aws_key_info']['key_alias'] = event['ResourceProperties']['KeyAlias']
              if 'ReuseKeyForClusterVolumes' in event['ResourceProperties']:
                postData['aws_key_info']['reuse_key_for_cluster_volumes'] = event['ResourceProperties']['ReuseKeyForClusterVolumes']
              response = http.request('POST', accountsAPIBaseURL + '/customer-managed-keys', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['customer_managed_key_id'])
              return
            if event['RequestType'] == 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/customer-managed-keys/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  ManagedKeysConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${ManagedKeysConfigurationFn}
      RetentionInDays: 365


  ### The workspace object
  WorkspaceFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-Workspace
      Description: The custom resource function to create a Databricks workspace
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 900
      Code:
        ZipFile: !Sub |
          import cfnresponse, urllib3, json, time
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] in ('Create', 'Update'):
              for propertName in ('WorkspaceName', 'CredentialsId', 'StorageId', 'NetworkId'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "credentials_id": event['ResourceProperties']['CredentialsId'],
                "network_id": event['ResourceProperties']['NetworkId']
              }
              if ('StorageKeyId' in event['ResourceProperties']) and (event['ResourceProperties']['StorageKeyId'] is not None) and (len(event['ResourceProperties']['StorageKeyId']) > 0):
                postData["storage_customer_managed_key_id"] = event['ResourceProperties']['StorageKeyId']
              if event['RequestType'] == 'Create':
                postData["workspace_name"] = event['ResourceProperties']['WorkspaceName']
                postData["aws_region"] = "${AWS::Region}"
                postData["storage_configuration_id"] = event['ResourceProperties']['StorageId']
                if ('ManagedServicesKeyId' in event['ResourceProperties']) and (event['ResourceProperties']['ManagedServicesKeyId'] is not None) and (len(event['ResourceProperties']['ManagedServicesKeyId']) > 0):
                  postData["managed_services_customer_managed_key_id"] = event['ResourceProperties']['ManagedServicesKeyId']
                if ('PrivateAccessId' in event['ResourceProperties']) and (event['ResourceProperties']['PrivateAccessId'] is not None) and (len(event['ResourceProperties']['PrivateAccessId']) > 0):
                  postData["private_access_settings_id"] = event['ResourceProperties']['PrivateAccessId']
              response = None
              if event['RequestType'] == 'Create':
                response = http.request('POST', accountsAPIBaseURL + '/workspaces', headers=myHeaders, body = json.dumps(postData))
              else:
                response = http.request('PATCH', accountsAPIBaseURL + '/workspaces/' + event['PhysicalResourceId'], headers=myHeaders, body = json.dumps(postData))
              if response.status not in (200, 201):
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              workspaceObject = json.loads(response.data.decode())
              workspaceId = str(workspaceObject['workspace_id'])
              deploymentName = workspaceObject['deployment_name']
              while True:
                time.sleep(5)
                try:
                  response = http.request('GET', accountsAPIBaseURL + '/workspaces/' + workspaceId, headers=myHeaders)
                  if json.loads(response.data.decode())['workspace_status'] == 'RUNNING': break
                except Exception as e:
                  print(str(e))
                  break
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {'DeploymentName': deploymentName}, workspaceId)
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/workspaces/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  WorkspaceLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${WorkspaceFn}
      RetentionInDays: 365


#-------------------------------------------------------------------------
Outputs:

  DatabricksAddressesFnArn:
    Description: The ARN of the CFN function returning the Databricks public addresses
    Value: !GetAtt DatabricksAddressesFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-DatabricksAddressesFn-Arn

  CredentialsConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks credentials configuration object
    Value: !GetAtt CredentialsConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-CredentialsConfigurationFn-Arn

  StorageConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks storage configuration object
    Value: !GetAtt StorageConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-StorageConfigurationFn-Arn

  VpcEnpointFnArn:
    Description: The ARN of the CFN function creating a Databricks VPC endpoint
    Value: !GetAtt VpcEnpointFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-VpcEnpointFn-Arn

  PrivateAccessConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks private access settings object
    Value: !GetAtt PrivateAccessConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-PrivateAccessConfigurationFn-Arn

  NetworkConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks network configuration object
    Value: !GetAtt NetworkConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-NetworkConfigurationFn-Arn

  ManagedKeysConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks managed keys configuration object
    Value: !GetAtt ManagedKeysConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-ManagedKeysConfigurationFn-Arn

  WorkspaceFnArn:
    Description: The ARN of the CFN function creating a Databricks workspace
    Value: !GetAtt WorkspaceFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-WorkspaceFn-Arn